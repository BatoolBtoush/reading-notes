# **Readings: API Deployment**

## **Configuring Django Settings**

Sensitive data. You have SECRET_KEY in each Django project. On top of this there can be DB passwords and tokens for third-party APIs like Amazon or Twitter. This data cannot be stored in VCS.

Members of a team can share settings. When working with the settings, you'll need a general approach to avoid human error. A developer may, for example, install a third-party app or API integration but neglect to provide appropriate parameters. This can be problematic on large (or even mid-sized) projects.

Django settings are written in Python. This is both a curse and a blessing in one. It allows you a lot of versatility, but it can also be an issue because it uses settings instead of key-value pairs. Python's reasoning can be somewhat perplexing.


<br>

## **django-environ**

Based on the above, we see that environment variables are the perfect place to store settings.

This app gives a well-functioning API for reading values from environment variables or text files, handful type conversion, etc. Let’s look at some examples.


### **settings.py file before:**

```
import os


SITE_ROOT = os.path.dirname(os.path.dirname(os.path.dirname(os.path.realpath(__file__))))

DEBUG = True
TEMPLATE_DEBUG = DEBUG

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql',
        'NAME': 'production_db',
        'USER': 'user',
        'PASSWORD': 'password',
        'HOST': 'db.example.com',
        'PORT': '5432',
        'OPTIONS': {
            'sslmode': 'require'
        }
    }
}

MEDIA_ROOT = os.path.join(SITE_ROOT, 'assets')
MEDIA_URL = 'media/'
STATIC_ROOT = os.path.join(SITE_ROOT, 'static')
STATIC_URL = 'static/'

SECRET_KEY = 'Some-Autogenerated-Secret-Key'

CACHES = {
    'default': {
        'BACKEND': 'django_redis.cache.RedisCache',
        'LOCATION': '127.0.0.1:6379/1',
    }
}
```

### **settings.py file after:**

```
import environ


root = environ.Path(__file__) - 3  # get root of the project
env = environ.Env()
environ.Env.read_env()  # reading .env file

SITE_ROOT = root()

DEBUG = env.bool('DEBUG', default=False)
TEMPLATE_DEBUG = DEBUG

DATABASES = {'default': env.db('DATABASE_URL')}

public_root = root.path('public/')
MEDIA_ROOT = public_root('media')
MEDIA_URL = env.str('MEDIA_URL', default='media/')
STATIC_ROOT = public_root('static')
STATIC_URL = env.str('STATIC_URL', default='static/')

SECRET_KEY = env.str('SECRET_KEY')

CACHES = {'default': env.cache('REDIS_CACHE_URL')}
```

### **.env file:**

```
DEBUG=True
DATABASE_URL=postgres://user:password@db.example.com:5432/production_db?sslmode=require
REDIS_CACHE_URL=redis://user:password@cache.example.com:6379/1
SECRET_KEY=Some-Autogenerated-Secret-Key
```

<br>

<br>


## **WhiteNoise**


WhiteNoise lets your web app to serve its own static files with just a few lines of configuration, making it a self-contained unit that can be deployed anywhere without relying on nginx, Amazon S3, or any other external service.


### **WhiteNois, takes care of best-practices for you:**

- Serving content that has been compressed (gzip and Brotli formats, handling Accept-Encoding and Vary headers correctly)

- Setting cache headers for material that won't change in the future

## **Installation**

1. ```pip install whitenoise```

2. Edit the *settings.py* file and add WhiteNoise to the MIDDLEWARE list, above all other middleware apart from Django’s SecurityMiddleware:
    ```
    MIDDLEWARE = [
        # ...
        "django.middleware.security.SecurityMiddleware",
        "whitenoise.middleware.WhiteNoiseMiddleware",
        # ...
    ]
    ```

3. If we want a forever-cacheable files and compression support? Just add this to your *settings.py*:
    ```
    STATICFILES_STORAGE = "whitenoise.storage.CompressedManifestStaticFilesStorage"
    ```